"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const uuid_1 = __importDefault(require("uuid"));
const texts_1 = require("./texts");
const dashboard_1 = require("./types/dashboard");
const upload_1 = require("./upload");
const error_decorator_1 = require("./error-decorator");
const report_commands_factory_1 = __importDefault(require("./report-commands-factory"));
const transport_1 = __importDefault(require("./transport"));
const assign_reporter_methods_1 = __importDefault(require("./assign-reporter-methods"));
const validate_settings_1 = __importDefault(require("./validate-settings"));
const blank_reporter_1 = __importDefault(require("./blank-reporter"));
function isThirdPartyError(error) {
    return error.code === 'E2';
}
function reporterObjectFactory(readFile, fetch, settings, logger) {
    if (!validate_settings_1.default(settings, logger))
        return blank_reporter_1.default;
    const { authenticationToken, buildId, dashboardUrl, isLogEnabled, noScreenshotUpload, noVideoUpload, runId } = settings;
    const id = runId || uuid_1.default();
    const transport = new transport_1.default(fetch, dashboardUrl, authenticationToken, isLogEnabled, logger);
    const uploader = new upload_1.Uploader(id, readFile, transport, logger);
    const reportCommands = report_commands_factory_1.default(id, transport);
    const testRunToActionsMap = {};
    const reporterPluginObject = { ...blank_reporter_1.default, createErrorDecorator: error_decorator_1.errorDecorator };
    assign_reporter_methods_1.default(reporterPluginObject, {
        async reportTaskStart(startTime, userAgents, testCount, taskStructure) {
            logger.log(texts_1.createReportUrlMessage(buildId || id, authenticationToken, dashboardUrl));
            await reportCommands.sendTaskStartCommand({ startTime, userAgents, testCount, buildId, taskStructure });
        },
        async reportFixtureStart() {
            return void 0;
        },
        async reportTestStart(name, meta, testStartInfo) {
            const { testId } = testStartInfo;
            await reportCommands.sendTestStartCommand({ testId });
        },
        async reportTestActionDone(apiActionName, actionInfo) {
            const { test: { phase }, command, testRunId, err, duration } = actionInfo;
            if (!testRunToActionsMap[testRunId])
                testRunToActionsMap[testRunId] = [];
            const action = {
                duration,
                apiName: apiActionName,
                testPhase: phase,
                command,
            };
            if (err) {
                action.error = dashboard_1.createTestError(err, error_decorator_1.curly(this.useWordWrap(false).setIndent(0).formatError(err)));
            }
            testRunToActionsMap[testRunId].push(action);
        },
        async reportTestDone(name, testRunInfo) {
            const { screenshots, videos, errs, durationMs, testId, browsers, skipped } = testRunInfo;
            const testRunToScreenshotsMap = {};
            const testRunToVideosMap = {};
            const testRunToErrorsMap = {};
            if (!noScreenshotUpload) {
                for (const screenshotInfo of screenshots) {
                    const { screenshotPath, testRunId } = screenshotInfo;
                    const uploadId = await uploader.uploadFile(screenshotPath);
                    if (!uploadId)
                        continue;
                    if (testRunToScreenshotsMap[testRunId])
                        testRunToScreenshotsMap[testRunId].push(uploadId);
                    else
                        testRunToScreenshotsMap[testRunId] = [uploadId];
                }
            }
            if (!noVideoUpload) {
                for (const videoInfo of videos) {
                    const { videoPath, testRunId } = videoInfo;
                    const uploadId = await uploader.uploadFile(videoPath);
                    if (!uploadId)
                        continue;
                    if (testRunToVideosMap[testRunId])
                        testRunToVideosMap[testRunId].push(uploadId);
                    else
                        testRunToVideosMap[testRunId] = [uploadId];
                }
            }
            for (const err of errs) {
                if (!isThirdPartyError(err))
                    continue;
                const { testRunId } = err;
                testRunToErrorsMap[testRunId] = dashboard_1.createTestError(err, error_decorator_1.curly(this.useWordWrap(false).setIndent(0).formatError(err)));
            }
            const browserRuns = browsers.reduce((runs, browser) => {
                const { testRunId } = browser;
                runs[testRunId] = {
                    browser,
                    screenshotUploadIds: testRunToScreenshotsMap[testRunId],
                    videoUploadIds: testRunToVideosMap[testRunId],
                    actions: testRunToActionsMap[testRunId],
                    thirdPartyError: testRunToErrorsMap[testRunId]
                };
                delete testRunToActionsMap[testRunId];
                return runs;
            }, {});
            const testDonePayload = {
                testId,
                skipped,
                errorCount: errs.length,
                duration: durationMs,
                uploadId: await uploader.uploadTest(name, dashboard_1.createDashboardTestRunInfo(testRunInfo, browserRuns))
            };
            await reportCommands.sendTestDoneCommand(testDonePayload);
        },
        async reportTaskDone(endTime, passed, warnings, result) {
            await uploader.waitUploads();
            await reportCommands.sendTaskDoneCommand({ endTime, passed, warnings, result, buildId });
        }
    }, isLogEnabled);
    return reporterPluginObject;
}
exports.default = reporterObjectFactory;
;
