"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = require("../consts");
const fetch_response_1 = __importDefault(require("./fetch-response"));
const texts_1 = require("../texts");
const MAX_RETRY_COUNT = 10;
function removeNullValues(key, value) {
    if (value !== null)
        return value;
    return void 0;
}
class Transport {
    constructor(fetch, dashboardUrl, authenticationToken, isLogEnabled, logger) {
        this._authenticationToken = authenticationToken;
        this._dashboardUrl = dashboardUrl;
        this._isLogEnabled = isLogEnabled;
        this._logger = logger;
        this._fetch = fetch;
    }
    async _sendCommand(command) {
        return this.fetch(`${this._dashboardUrl}/api/commands/`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Cookie': `tc-dashboard-jwt=${this._authenticationToken}`
            },
            body: JSON.stringify(command, removeNullValues)
        });
    }
    async fetch(url, requestOptions) {
        let retryCount = 0;
        do {
            try {
                return new fetch_response_1.default(await this._fetch(url, requestOptions));
            }
            catch (e) {
                if (this._isLogEnabled)
                    this._logger.log(`${texts_1.FETCH_NETWORK_CONNECTION_ERROR} ${url}. Retry count: ${retryCount}`);
                if (consts_1.RETRY_ERROR_CODES.includes(e.code) && retryCount++ < MAX_RETRY_COUNT)
                    continue;
                else
                    return new fetch_response_1.default(null, texts_1.FETCH_NETWORK_CONNECTION_ERROR, e);
            }
        } while (true);
    }
    async fetchFromDashboard(relativeUrl) {
        return await this.fetch(`${this._dashboardUrl}/${relativeUrl}`, {
            method: 'GET',
            headers: {
                authorization: `Bearer ${this._authenticationToken}`
            }
        });
    }
    async sendResolveCommand(command) {
        const { aggregateId, type: commandType } = command;
        if (!this._authenticationToken)
            return;
        let response = null;
        let retryCount = 0;
        do {
            response = await this._sendCommand(command);
            retryCount++;
            if (!response.ok)
                this._logger.error(`${aggregateId} ${commandType} ${response}`);
            else if (this._isLogEnabled)
                this._logger.log(`${aggregateId} ${commandType} ${response}`);
        } while (response.status === consts_1.CONCURRENT_ERROR_CODE && retryCount <= MAX_RETRY_COUNT);
    }
}
exports.default = Transport;
